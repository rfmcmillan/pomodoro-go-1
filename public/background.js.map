{"version":3,"sources":["webpack://pomodoro_go/./client/background.js","webpack://pomodoro_go/./client/storage.js"],"names":["storage","tabs","runtime","alarms","scripting","chrome","action","onClicked","addListener","tab","create","url","active","currentTab","sessionTime","appStarted","getCurrentTab","async","query","currentWindow","init","this","console","log","sync","clear","local","set","isRunning","clearAll","listenForAlarm","listenToExternalMessages","listenToStorage","listenToTabs","listenForBlockedSite","listenForDashboardRedirect","error","createAlarm","when","Date","now","alarmCreated","resetStorage","timerOn","currentSession","sessionComplete","user","email","onMessageExternal","message","sender","sendResponse","sites","blockedSites","forEach","site","push","siteUrl","blocked","currUser","get","results","find","toggleSite","update","filter","each","onChanged","changes","namespace","key","oldValue","newValue","Object","entries","JSON","stringify","onUpdated","tabId","changeInfo","reduce","previous","current","lastAccessed","pendingUrl","startsWith","hostname","URL","userAttempt","Array","isArray","domain","includes","options","method","headers","body","fetch","err","onAlarm","alarm","name","notifications","undefined","type","title","iconUrl","requireInteraction","silent","lastError","onButtonClicked","notificationId","buttonIdx","id","periodInMinutes","Promise","resolve","res","blackList","then","blackListUrls"],"mappings":"mBACA,MAAM,QAAEA,EAAF,KAAWC,EAAX,QAAiBC,EAAjB,OAA0BC,EAA1B,UAAkCC,GAAcC,OAwBtDA,OAAOC,OAAOC,UAAUC,aAAaC,IACnCJ,OAAOJ,KAAKS,OAAO,CACjBC,IAAK,kBAIU,CACjBC,QAAQ,EACRC,WAAY,KACZC,YAAa,EACbC,YAAY,EACZC,cAAeC,iBACb,IACKR,SAAaJ,OAAOJ,KAAKiB,MADX,CAAEN,QAAQ,EAAMO,eAAe,IAElD,OAAOV,GAETW,KAAMH,iBACJ,IACOI,KAAKT,SACRU,QAAQC,IAAI,gBACZvB,EAAQwB,KAAKC,SACM,EC1BzBpB,OAAOL,QAAQ0B,MAAMC,IAAI,CAAEC,UD0BF,QAEnBzB,EAAO0B,UAAS,KACdP,QAAQC,IAAI,yBAGdF,KAAKS,iBACLT,KAAKU,2BACLV,KAAKW,kBACLX,KAAKY,eACLZ,KAAKa,uBACLb,KAAKc,6BACLd,KAAKT,QAAS,GAEhBS,KAAKR,iBAAmBQ,KAAKL,gBAC7B,MAAOoB,GACPd,QAAQC,IAAI,uCAAwCa,KAGxDC,YAAa,WACXhC,OAAOF,OAAOO,OAAO,QAAS,CAC5B4B,KAAMC,KAAKC,MAAQnB,KAAKP,cAE1BO,KAAKoB,cAAe,EACpBpC,OAAOL,QAAQwB,KAAKG,IAAI,CAAEc,cAAc,KAE1CC,eACE1C,EAAQ0B,MAAMC,IAAI,CAChBb,YAAa,EACb6B,SAAS,EACTC,eAAgB,GAChBH,cAAc,EACdI,iBAAiB,EACjBC,KAAM,GACNC,MAAO,MAIXhB,yBAA0B,WACxB,OAAO7B,EAAQ8C,kBAAkBxC,aAC/BS,MAAOgC,EAASC,EAAQC,KACtB,IAkBE,GAjBwB,iBAApBF,EAAQA,UACV5B,KAAKP,YAAcmC,EAAQnC,YAC3BO,KAAKgB,eAEiB,mBAApBY,EAAQA,UACV3B,QAAQC,IAAI,kCACZpB,EAAO0B,UAAS,KACdP,QAAQC,IAAI,4BACZpB,EAAOO,OAAO,QAAS,CACrB4B,KAAMC,KAAKC,MAAQS,EAAQnC,cAE7BQ,QAAQC,IAAI,yBAGQ,eAApB0B,EAAQA,SACV9C,EAAOO,OAAO,QAAS,CAAE4B,KAAMC,KAAKC,QAEd,sBAApBS,EAAQA,QAAiC,CAC3C3B,QAAQC,IAAI,sCACZ,MAAM6B,EAAQ,GACdH,EAAQI,aAAaC,SAASC,IAC5BH,EAAMI,KAAKD,EAAKE,YAElBpD,OAAOL,QAAQwB,KAAKG,IAClB,CAAE+B,QAASN,EAAOO,SAAUV,EAAQU,WACpC,KACErC,QAAQC,IAAI,kCAGhBD,QAAQC,IAAI,gBAAiB0B,GAC7B5C,OAAOL,QAAQwB,KAAKoC,IAAI,MAAOC,IAC7BvC,QAAQC,IAAI,yBAA0BsC,MAGlB,wBAApBZ,EAAQA,SACV5C,OAAOL,QAAQwB,KAAKoC,IAAI,CAAC,YAAaC,IAIpC,GAHoBA,EAAQH,QAAQI,MAAMnD,GACjCA,IAAQsC,EAAQc,aAER,CACf,MAAMC,EAASH,EAAQH,QAAQO,QAAQC,GAC9BA,IAASjB,EAAQc,aAE1B1D,OAAOL,QAAQwB,KAAKG,IAAI,CAAE+B,QAASM,SAEnCH,EAAQH,QAAQF,KAAKP,EAAQc,YAC7B1D,OAAOL,QAAQwB,KAAKG,IAAI,CAAE+B,QAASG,EAAQH,aAIjD,MAAOtB,GACPd,QAAQC,IAAIa,QAKpBJ,gBAAiB,WACf,OAAOhC,EAAQmE,UAAU3D,aAAYS,eAAgBmD,EAASC,GAI5D,IAAK,IAAKC,GAAK,SAAEC,EAAF,SAAYC,MAAeC,OAAOC,QAAQN,GACvD9C,QAAQC,IACL,gBAAe+C,oBAAsBD,cACrC,kBAAiBM,KAAKC,UACrBL,sBACmBI,KAAKC,UAAUJ,YAK5CvC,aAAc,WACZ,OAAOhC,EAAK4E,UAAUrE,aAAY,SAAUsE,EAAOC,GACjDzD,QAAQC,IAAI,2BAA4BuD,GACxCzE,OAAOJ,KAAKiB,MAAM,CAAEN,QAAQ,IAAUX,IAC1BA,EAAK+E,QAAO,CAACC,EAAUC,IACxBD,EAASE,aAAeD,EAAQC,aACnCF,EACAC,OAGR7E,OAAOL,QAAQwB,KAAKoC,IAAI,MAAOC,IAC7B,MAAM,eACJjB,EADI,aAEJH,EAFI,gBAGJI,EAHI,YAIJ/B,EAJI,QAKJ6B,GACEkB,EACElD,EAAMoE,EAAWK,YAAcL,EAAWpE,IAChD,IAAKA,IAAQA,EAAI0E,WAAW,QAC1B,OAEF,MAAMC,EAAW,IAAIC,IAAI5E,GAAK2E,SAE9BtF,EAAQwB,KAAKG,IAAI,CAAE6D,YAAaF,IAEhCtF,EAAQwB,KAAKoC,IAAI,CAAC,UAAW,aAAa3C,eAAgBO,GACxD,MAAM,QAAEkC,EAAF,SAAWC,GAAanC,EAC9B,GACEiE,MAAMC,QAAQhC,IACdA,EAAQI,MAAM6B,GACLA,EAAOC,SAASN,KAEzB,CACA,MAAMO,EAAU,CACdC,OAAQ,OACRC,QAAS,CACP,eACE,oDAEJC,KAAO,iBAAgBV,YAAmB3B,KAG5C,UACQsC,MACJ,iDACAJ,GAEF,MAAOK,GACP5E,QAAQc,MAAM,iBAAkB8D,GAGlC7F,OAAOJ,KAAK+D,OAAOc,EAAO,CACxBnE,IAAK,wDA2BjBmB,eAAgB,WACd,OAAOzB,OAAOF,OAAOgG,QAAQ3F,aAAY,SAAU4F,GAC9B,eAAfA,EAAMC,OACRhG,OAAOiG,cAAc5F,YACnB6F,EACA,CACEC,KAAM,QACNC,MAAO,kCACPxD,QAAS,iCACTyD,QAAS,gBACTC,oBAAoB,EACpBC,QAAQ,IAEV,KACEtF,QAAQC,IAAI,eAAgBlB,OAAOH,QAAQ2G,cAG/CxG,OAAOL,QAAQ0B,MAAMC,IAAI,CACvBc,cAAc,EACdG,eAAgB,GAChBD,SAAS,EACT7B,YAAa,EACb+B,iBAAiB,SAKzBV,2BAA4B,WAE1B,OAAO9B,OAAOiG,cAAcQ,gBAAgBtG,aAC1CS,MAAO8F,EAAgBC,KAErB,IAAIvG,QAAYY,KAAKL,gBACrBX,OAAOJ,KAAK+D,OAAOvD,EAAIwG,GAAI,CACzBtG,IAAK,uDAOJS,OAGXf,OAAOF,OAAOO,OAAO,YAAa,CAChCwG,gBAAiB,EAAI,KAyBvB7G,OAAOJ,KAAK4E,UAAUrE,aAAY,SAAesE,EAAOC,GAClDA,EAAWpE,KC1SR,IAAIwG,SAASC,IAClB/G,OAAOL,QAAQ0B,MAAMkC,IAAI,CAAC,cAAeyD,IACvCD,EAAQC,EAAIC,iBD2SOC,MAAMC,IACzBlG,QAAQC,IAAI,oCAAqCiG,GAC7CA,GACEA,EAAc5B,SAASb,EAAWpE,MACpCN,OAAOJ,KAAK+D,OAAOc,EAAO,CACxBnE,IAAM,oD","file":"background.js","sourcesContent":["'use strict';\nconst { storage, tabs, runtime, alarms, scripting } = chrome;\nimport { getStoredBlackList } from './storage';\nimport {\n  setStoredIsRunning,\n  setStoredTimer,\n  setStoredDisplayTime,\n} from './storage';\n\nconst msToHMS = (ms) => {\n  let seconds = ms / 1000;\n\n  let hours = parseInt(seconds / 3600);\n  seconds = seconds % 3600;\n\n  let minutes = parseInt(seconds / 60);\n  seconds = seconds % 60;\n\n  hours = hours < 10 ? '0' + hours : hours;\n  minutes = minutes < 10 ? '0' + minutes : minutes;\n  seconds = seconds < 10 ? (seconds >= 0 ? '0' + seconds : '00') : seconds;\n\n  return hours + ':' + minutes + ':' + seconds;\n};\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.tabs.create({\n    url: 'index.html',\n  });\n});\n\nconst background = {\n  active: false,\n  currentTab: null,\n  sessionTime: 0,\n  appStarted: false,\n  getCurrentTab: async function () {\n    let queryOptions = { active: true, currentWindow: true };\n    let [tab] = await chrome.tabs.query(queryOptions);\n    return tab;\n  },\n  init: async function () {\n    try {\n      if (!this.active) {\n        console.log('running app!');\n        storage.sync.clear();\n        setStoredIsRunning(false);\n        // setStoredTimer(null);\n        alarms.clearAll(() => {\n          console.log('alarms are cleared');\n        });\n\n        this.listenForAlarm();\n        this.listenToExternalMessages();\n        this.listenToStorage();\n        this.listenToTabs();\n        this.listenForBlockedSite();\n        this.listenForDashboardRedirect();\n        this.active = true;\n      }\n      this.currentTab = await this.getCurrentTab();\n    } catch (error) {\n      console.log('issue with start up in background js', error);\n    }\n  },\n  createAlarm: function () {\n    chrome.alarms.create('timer', {\n      when: Date.now() + this.sessionTime,\n    });\n    this.alarmCreated = true;\n    chrome.storage.sync.set({ alarmCreated: true });\n  },\n  resetStorage() {\n    storage.local.set({\n      sessionTime: 0,\n      timerOn: false,\n      currentSession: {},\n      alarmCreated: false,\n      sessionComplete: false,\n      user: {},\n      email: '',\n    });\n  },\n\n  listenToExternalMessages: function () {\n    return runtime.onMessageExternal.addListener(\n      async (message, sender, sendResponse) => {\n        try {\n          if (message.message === 'create-timer') {\n            this.sessionTime = message.sessionTime;\n            this.createAlarm();\n          }\n          if (message.message === 'continue-alarm') {\n            console.log('you want me to start an alarm?');\n            alarms.clearAll(() => {\n              console.log('alarms are cleared again');\n              alarms.create('timer', {\n                when: Date.now() + message.sessionTime,\n              });\n              console.log('new alarm created');\n            });\n          }\n          if (message.message === 'timer-done') {\n            alarms.create('timer', { when: Date.now() });\n          }\n          if (message.message === 'set-blocked-sites') {\n            console.log('set-blocked-sites message received');\n            const sites = [];\n            message.blockedSites.forEach((site) => {\n              sites.push(site.siteUrl);\n            });\n            chrome.storage.sync.set(\n              { blocked: sites, currUser: message.currUser },\n              () => {\n                console.log('sites are blocked in chrome');\n              }\n            );\n            console.log('blocked sites', message);\n            chrome.storage.sync.get(null, (results) => {\n              console.log('current chrome storage', results);\n            });\n          }\n          if (message.message === 'toggle-block-or-not') {\n            chrome.storage.sync.get(['blocked'], (results) => {\n              const doesItExist = results.blocked.find((url) => {\n                return url === message.toggleSite;\n              });\n              if (doesItExist) {\n                const update = results.blocked.filter((each) => {\n                  return each !== message.toggleSite;\n                });\n                chrome.storage.sync.set({ blocked: update });\n              } else {\n                results.blocked.push(message.toggleSite);\n                chrome.storage.sync.set({ blocked: results.blocked });\n              }\n            });\n          }\n        } catch (error) {\n          console.log(error);\n        }\n      }\n    );\n  },\n  listenToStorage: function () {\n    return storage.onChanged.addListener(async function (changes, namespace) {\n      // logging out the changes in storage\n      // THIS CODE IS FOR DEV PURPOSES\n      // YOU WILL HAVE ALOT OF LOGS IN CONSOLE\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${JSON.stringify(\n            oldValue\n          )}\", new value is \"${JSON.stringify(newValue)}\".`\n        );\n      }\n    });\n  },\n  listenToTabs: function () {\n    return tabs.onUpdated.addListener(function (tabId, changeInfo) {\n      console.log('listening to tabs, tabID', tabId);\n      chrome.tabs.query({ active: false }, (tabs) => {\n        let tab = tabs.reduce((previous, current) => {\n          return previous.lastAccessed > current.lastAccessed\n            ? previous\n            : current;\n        });\n      });\n      chrome.storage.sync.get(null, (results) => {\n        const {\n          currentSession,\n          alarmCreated,\n          sessionComplete,\n          sessionTime,\n          timerOn,\n        } = results;\n        const url = changeInfo.pendingUrl || changeInfo.url;\n        if (!url || !url.startsWith('http')) {\n          return;\n        }\n        const hostname = new URL(url).hostname;\n\n        storage.sync.set({ userAttempt: hostname });\n\n        storage.sync.get(['blocked', 'currUser'], async function (sync) {\n          const { blocked, currUser } = sync;\n          if (\n            Array.isArray(blocked) &&\n            blocked.find((domain) => {\n              return domain.includes(hostname);\n            })\n          ) {\n            const options = {\n              method: 'post',\n              headers: {\n                'Content-type':\n                  'application/x-www-form-urlencoded; charset=UTF-8',\n              },\n              body: `userAttempted=${hostname}&userId=${currUser}`,\n            };\n\n            try {\n              await fetch(\n                'https://pomodoro-go-1.herokuapp.com/api/blocks',\n                options\n              );\n            } catch (err) {\n              console.error('Request failed', err);\n            }\n\n            chrome.tabs.update(tabId, {\n              url: 'https://pomodoro-go-1.herokuapp.com/uhoh',\n            }); // hard-code it to production url atm instead of 'http://localhost:8080/uhoh'\n          }\n        });\n      });\n    });\n  },\n\n  // listenForBlockedSite: function () {\n  //   return chrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n  //     if (changeInfo.url) {\n  //       // const hostname = new URL(url).hostname;\n  //       // console.log(hostname);\n  //       getStoredBlackList().then((blackListUrls) => {\n  //         console.log('storedBlackList in background.js:', blackListUrls);\n  //         if (blackListUrls) {\n  //           if (blackListUrls.includes(changeInfo.url)) {\n  //             chrome.tabs.update(tabId, {\n  //               url: `${process.env.API_URL}/uhoh`,\n  //             });\n  //           }\n  //         }\n  //       });\n  //     }\n  //   });\n  // },\n\n  listenForAlarm: function () {\n    return chrome.alarms.onAlarm.addListener(function (alarm) {\n      if (alarm.name === 'startTimer') {\n        chrome.notifications.create(\n          undefined,\n          {\n            type: 'basic',\n            title: 'Your focus session is complete!',\n            message: 'Nice job! You deserve a break!',\n            iconUrl: 'logo-pomo.png',\n            requireInteraction: true,\n            silent: false,\n          },\n          () => {\n            console.log('last error: ', chrome.runtime.lastError);\n          }\n        );\n        chrome.storage.local.set({\n          alarmCreated: false,\n          currentSession: {},\n          timerOn: false,\n          sessionTime: 0,\n          sessionComplete: true,\n        });\n      }\n    });\n  },\n  listenForDashboardRedirect: function () {\n    // THIS BUTTON WORKS BUT DASHBOARD DOES NOT LOAD\n    return chrome.notifications.onButtonClicked.addListener(\n      async (notificationId, buttonIdx) => {\n        // redirects to dashboard after session is complete\n        let tab = await this.getCurrentTab();\n        chrome.tabs.update(tab.id, {\n          url: 'https://pomodoro-go-1.herokuapp.com/dashboard',\n        });\n      }\n    );\n  },\n};\n\nbackground.init();\n\n//Timer in Background\nchrome.alarms.create('oneSecond', {\n  periodInMinutes: 1 / 60,\n});\n\n// chrome.alarms.onAlarm.addListener((alarm) => {\n//   if (alarm.name === 'oneSecond') {\n//     chrome.storage.local.get(['isRunning', 'timer'], (res) => {\n//       console.log('res.timer in background.js:', res.timer);\n//       console.log('res.isRunning:', res.isRunning);\n//       const time = res.timer ?? 0;\n\n//       if (time === 0) {\n//         setStoredIsRunning(false);\n//         return;\n//       }\n//       if (!res.isRunning) {\n//         return;\n//       }\n//       const displayTime = msToHMS(time - 1000);\n//       setStoredDisplayTime(displayTime);\n//       console.log('time in background.js:', time);\n//       setStoredTimer(time - 1000);\n//     });\n//   }\n// });\n\nchrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n  if (changeInfo.url) {\n    // const hostname = new URL(url).hostname;\n    // console.log(hostname);\n    getStoredBlackList().then((blackListUrls) => {\n      console.log('storedBlackList in background.js:', blackListUrls);\n      if (blackListUrls) {\n        if (blackListUrls.includes(changeInfo.url)) {\n          chrome.tabs.update(tabId, {\n            url: `${process.env.API_URL}/uhoh`,\n          });\n        }\n      }\n    });\n  }\n});\n","export function setStoredBlackList(blackList) {\n  const vals = {\n    blackList,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredBlackList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['blackList'], (res) => {\n      resolve(res.blackList);\n    });\n  });\n}\n\nexport function setStoredIsRunning(isRunning) {\n  chrome.storage.local.set({ isRunning });\n}\n\nexport function getStoredIsRunning() {\n  chrome.storage.local.get(['isRunning'], (res) => {\n    resolve(res.isRunning);\n  });\n}\n\nexport function setStoredTimer(timer) {\n  const vals = {\n    timer,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredTimer() {\n  chrome.storage.local.get(['timer'], (res) => {\n    resolve(res.timer);\n  });\n}\n\nexport function setStoredDisplayTime(displayTime) {\n  const vals = {\n    displayTime,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredDisplayTime() {\n  chrome.storage.local.get(['displayTime'], (res) => {\n    resolve(res.displayTime);\n  });\n}\n\nexport function setStoredAuth(auth) {\n  const vals = {\n    auth,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredAuth() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['auth'], (res) => {\n      resolve(res.auth);\n    });\n  });\n}\n"],"sourceRoot":""}
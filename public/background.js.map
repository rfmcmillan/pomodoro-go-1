{"version":3,"sources":["webpack://pomodoro_go/./client/background.js","webpack://pomodoro_go/./client/storage.js"],"names":["storage","tabs","runtime","alarms","chrome","timerID","timerTime","action","onClicked","addListener","tab","create","url","active","sessionTime","init","async","this","clearAll","console","log","listenForAlarm","error","onAlarm","alarm","name","notifications","undefined","type","title","message","iconUrl","requireInteraction","silent","lastError","local","set","alarmCreated","currentSession","timerOn","sessionComplete","onUpdated","tabId","changeInfo","Promise","resolve","get","res","blackList","then","blackListUrls","i","length","includes","update","onMessage","request","sender","sendResponse","cmd","Date","when","setTimeout","now","getTime","time"],"mappings":"mBACA,MAAM,QAAEA,EAAF,KAAWC,EAAX,QAAiBC,EAAjB,OAA0BC,GAAWC,OA4E3C,IAAIC,EACAC,EA1EJF,OAAOG,OAAOC,UAAUC,aAAaC,IACnCT,EAAKU,OAAO,CACVC,IAAK,kBAIU,CACjBC,QAAQ,EACRC,YAAa,EACbC,KAAMC,iBACJ,IACOC,KAAKJ,SACRV,EAAOe,UAAS,KACdC,QAAQC,IAAI,yBAEdH,KAAKI,iBACLJ,KAAKJ,QAAS,GAEhB,MAAOS,GACPH,QAAQC,IAAI,uCAAwCE,KAIxDD,eAAgB,WACd,OAAOlB,EAAOoB,QAAQd,aAAY,SAAUe,GACvB,eAAfA,EAAMC,OACRrB,OAAOsB,cAAcf,YACnBgB,EACA,CACEC,KAAM,QACNC,MAAO,kCACPC,QAAS,iCACTC,QAAS,gBACTC,oBAAoB,EACpBC,QAAQ,IAEV,KACEd,QAAQC,IAAI,eAAgBlB,EAAQgC,cAGxClC,EAAQmC,MAAMC,IAAI,CAChBC,cAAc,EACdC,eAAgB,GAChBC,SAAS,EACTzB,YAAa,EACb0B,iBAAiB,UAOhBzB,OAEXd,EAAKwC,UAAUhC,aAAY,SAAeiC,EAAOC,GAC3CA,EAAW/B,KC/CR,IAAIgC,SAASC,IAClBzC,OAAOJ,QAAQmC,MAAMW,IAAI,CAAC,cAAeC,IACvCF,EAAQE,EAAIC,iBD8COC,MAAMC,IACzB,GAAIA,EACF,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAcE,OAAQD,IAEtCR,EAAW/B,IAAIyC,SAASH,EAAcC,KACtCD,EAAcC,GAAGC,QAEjBnD,EAAKqD,OAAOZ,EAAO,CACjB9B,IAAM,sDAYpBV,EAAQqD,UAAU9C,aAAY,CAAC+C,EAASC,EAAQC,KAC1B,gBAAhBF,EAAQG,KACVrD,EAAY,IAAIsD,KAAKJ,EAAQK,MAC7BxD,EAAUyD,YAAW,KACnB1D,OAAOD,OAAOQ,OAAO,aAAc,CAAEkD,KAAMD,KAAKG,QAChDzD,EAAY,IACXA,EAAU0D,UAAYJ,KAAKG,QACL,aAAhBP,EAAQG,KACjBD,EAAa,CAAEO,KAAM3D,Q","file":"background.js","sourcesContent":["'use strict';\nconst { storage, tabs, runtime, alarms } = chrome;\nimport { getStoredBlackList } from './storage';\n\nchrome.action.onClicked.addListener((tab) => {\n  tabs.create({\n    url: 'index.html',\n  });\n});\n\nconst background = {\n  active: false,\n  sessionTime: 0,\n  init: async function () {\n    try {\n      if (!this.active) {\n        alarms.clearAll(() => {\n          console.log('alarms are cleared');\n        });\n        this.listenForAlarm();\n        this.active = true;\n      }\n    } catch (error) {\n      console.log('issue with start up in background js', error);\n    }\n  },\n\n  listenForAlarm: function () {\n    return alarms.onAlarm.addListener(function (alarm) {\n      if (alarm.name === 'startTimer') {\n        chrome.notifications.create(\n          undefined,\n          {\n            type: 'basic',\n            title: 'Your focus session is complete!',\n            message: 'Nice job! You deserve a break!',\n            iconUrl: 'logo-pomo.png',\n            requireInteraction: true,\n            silent: false,\n          },\n          () => {\n            console.log('last error: ', runtime.lastError);\n          }\n        );\n        storage.local.set({\n          alarmCreated: false,\n          currentSession: {},\n          timerOn: false,\n          sessionTime: 0,\n          sessionComplete: true,\n        });\n      }\n    });\n  },\n};\n\nbackground.init();\n\ntabs.onUpdated.addListener(function async(tabId, changeInfo) {\n  if (changeInfo.url) {\n    getStoredBlackList().then((blackListUrls) => {\n      if (blackListUrls) {\n        for (let i = 0; i < blackListUrls.length; i++) {\n          if (\n            changeInfo.url.includes(blackListUrls[i]) &&\n            blackListUrls[i].length\n          ) {\n            tabs.update(tabId, {\n              url: `${process.env.API_URL}/blocked`,\n            });\n          }\n        }\n      }\n    });\n  }\n});\n\nlet timerID;\nlet timerTime;\n\nruntime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.cmd === 'START_TIMER') {\n    timerTime = new Date(request.when);\n    timerID = setTimeout(() => {\n      chrome.alarms.create('startTimer', { when: Date.now() });\n      timerTime = 0;\n    }, timerTime.getTime() - Date.now());\n  } else if (request.cmd === 'GET_TIME') {\n    sendResponse({ time: timerTime });\n  }\n});\n","export function setStoredBlackList(blackList) {\n  const vals = {\n    blackList,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredBlackList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['blackList'], (res) => {\n      resolve(res.blackList);\n    });\n  });\n}\n\nexport function setStoredIsRunning(isRunning) {\n  chrome.storage.local.set({ isRunning });\n}\n\nexport function getStoredIsRunning() {\n  chrome.storage.local.get(['isRunning'], (res) => {\n    resolve(res.isRunning);\n  });\n}\n\nexport function setStoredTimer(timer) {\n  const vals = {\n    timer,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredTimer() {\n  chrome.storage.local.get(['timer'], (res) => {\n    resolve(res.timer);\n  });\n}\n\nexport function setStoredDisplayTime(displayTime) {\n  const vals = {\n    displayTime,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredDisplayTime() {\n  chrome.storage.local.get(['displayTime'], (res) => {\n    resolve(res.displayTime);\n  });\n}\n\nexport function setStoredAuth(auth) {\n  const vals = {\n    auth,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredAuth() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['auth'], (res) => {\n      resolve(res.auth);\n    });\n  });\n}\n"],"sourceRoot":""}
{"version":3,"sources":["webpack://pomodoro_go/./client/background.js","webpack://pomodoro_go/./client/storage.js"],"names":["storage","tabs","runtime","alarms","scripting","chrome","action","onClicked","addListener","tab","console","log","create","url","active","currentTab","sessionTime","appStarted","getCurrentTab","async","query","currentWindow","init","this","sync","clear","clearAll","listenForAlarm","listenToExternalMessages","listenToStorage","listenToTabs","listenForBlockedSite","listenForDashboardRedirect","error","createAlarm","when","Date","now","alarmCreated","set","resetStorage","local","timerOn","currentSession","sessionComplete","user","email","onMessageExternal","message","sender","sendResponse","sites","blockedSites","forEach","site","push","siteUrl","blocked","currUser","get","results","toggleSite","find","update","filter","each","onChanged","changes","namespace","key","oldValue","newValue","Object","entries","JSON","stringify","onUpdated","tabId","changeInfo","reduce","previous","current","lastAccessed","pendingUrl","startsWith","hostname","URL","userAttempt","Array","isArray","domain","includes","options","method","headers","body","fetch","err","Promise","resolve","res","blackList","then","onAlarm","alarm","notifications","undefined","type","title","iconUrl","requireInteraction","silent","lastError","onButtonClicked","notificationId","buttonIdx","id"],"mappings":"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","file":"background.js","sourcesContent":["'use strict';\nconst { storage, tabs, runtime, alarms, scripting } = chrome;\nimport { getStoredAuth, getStoredBlackList } from './storage';\n\nchrome.action.onClicked.addListener((tab) => {\n  console.log('new tab created');\n  chrome.tabs.create({\n    url: 'index.html',\n  });\n});\n\nconst background = {\n  active: false,\n  currentTab: null,\n  sessionTime: 0,\n  appStarted: false,\n  getCurrentTab: async function () {\n    let queryOptions = { active: true, currentWindow: true };\n    let [tab] = await chrome.tabs.query(queryOptions);\n    return tab;\n  },\n  init: async function () {\n    try {\n      if (!this.active) {\n        console.log('running app!');\n        storage.sync.clear();\n        alarms.clearAll(() => {\n          console.log('alarms are cleared');\n        });\n\n        this.listenForAlarm();\n        this.listenToExternalMessages();\n        this.listenToStorage();\n        this.listenToTabs();\n        // this.listenForBlackListIncrement();\n        this.listenForBlockedSite();\n        this.listenForDashboardRedirect();\n        this.active = true;\n      }\n      this.currentTab = await this.getCurrentTab();\n    } catch (error) {\n      console.log('issue with start up in background js', error);\n    }\n  },\n  createAlarm: function () {\n    chrome.alarms.create('timer', {\n      when: Date.now() + this.sessionTime,\n    });\n    this.alarmCreated = true;\n    chrome.storage.sync.set({ alarmCreated: true });\n    console.log('alarm creeated!!!');\n  },\n  resetStorage() {\n    storage.local.set({\n      sessionTime: 0,\n      timerOn: false,\n      currentSession: {},\n      alarmCreated: false,\n      sessionComplete: false,\n      user: {},\n      email: '',\n    });\n  },\n\n  listenToExternalMessages: function () {\n    return runtime.onMessageExternal.addListener(\n      async (message, sender, sendResponse) => {\n        try {\n          if (message.message === 'create-timer') {\n            this.sessionTime = message.sessionTime;\n            this.createAlarm();\n          }\n          if (message.message === 'continue-alarm') {\n            console.log('you want me to start an alarm?');\n            alarms.clearAll(() => {\n              console.log('alarms are cleared again');\n              alarms.create('timer', {\n                when: Date.now() + message.sessionTime,\n              });\n              console.log('new alarm created');\n            });\n          }\n          if (message.message === 'timer-done') {\n            alarms.create('timer', { when: Date.now() });\n          }\n          if (message.message === 'set-blocked-sites') {\n            console.log('set-blocked-sites message received');\n            const sites = [];\n            message.blockedSites.forEach((site) => {\n              sites.push(site.siteUrl);\n            });\n            chrome.storage.sync.set(\n              { blocked: sites, currUser: message.currUser },\n              () => {\n                console.log('sites are blocked in chrome');\n              }\n            );\n            console.log('blocked sites', message);\n            chrome.storage.sync.get(null, (results) => {\n              console.log('current chrome storage', results);\n            });\n          }\n          if (message.message === 'toggle-block-or-not') {\n            console.log('user is toggleing a blocked site', message.toggleSite);\n            chrome.storage.sync.get(['blocked'], (results) => {\n              const doesItExist = results.blocked.find((url) => {\n                return url === message.toggleSite;\n              });\n              if (doesItExist) {\n                const update = results.blocked.filter((each) => {\n                  return each !== message.toggleSite;\n                });\n                chrome.storage.sync.set({ blocked: update });\n              } else {\n                results.blocked.push(message.toggleSite);\n                chrome.storage.sync.set({ blocked: results.blocked });\n              }\n            });\n          }\n        } catch (error) {\n          console.log(error);\n        }\n      }\n    );\n  },\n  listenToStorage: function () {\n    return storage.onChanged.addListener(async function (changes, namespace) {\n      // logging out the changes in storage\n      // THIS CODE IS FOR DEV PURPOSES\n      // YOU WILL HAVE ALOT OF LOGS IN CONSOLE\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${JSON.stringify(\n            oldValue\n          )}\", new value is \"${JSON.stringify(newValue)}\".`\n        );\n      }\n    });\n  },\n  listenToTabs: function () {\n    return tabs.onUpdated.addListener(function (tabId, changeInfo) {\n      console.log('listening to tabs, tabID', tabId);\n      chrome.tabs.query({ active: false }, (tabs) => {\n        let tab = tabs.reduce((previous, current) => {\n          return previous.lastAccessed > current.lastAccessed\n            ? previous\n            : current;\n        });\n      });\n      chrome.storage.sync.get(null, (results) => {\n        const {\n          currentSession,\n          alarmCreated,\n          sessionComplete,\n          sessionTime,\n          timerOn,\n        } = results;\n        const url = changeInfo.pendingUrl || changeInfo.url;\n        if (!url || !url.startsWith('http')) {\n          return;\n        }\n        const hostname = new URL(url).hostname;\n\n        storage.sync.set({ userAttempt: hostname });\n\n        storage.sync.get(['blocked', 'currUser'], async function (sync) {\n          const { blocked, currUser } = sync;\n          console.log('blocked:', blocked);\n          console.log('currUser:', currUser);\n          if (\n            Array.isArray(blocked) &&\n            blocked.find((domain) => {\n              return domain.includes(hostname);\n            })\n          ) {\n            const options = {\n              method: 'post',\n              headers: {\n                'Content-type':\n                  'application/x-www-form-urlencoded; charset=UTF-8',\n              },\n              body: `userAttempted=${hostname}&userId=${currUser}`,\n            };\n\n            try {\n              await fetch(\n                'https://pomodoro-go-1.herokuapp.com/api/blocks',\n                options\n              );\n            } catch (err) {\n              console.error('Request failed', err);\n            }\n\n            chrome.tabs.update(tabId, {\n              url: 'https://pomodoro-go-1.herokuapp.com/uhoh',\n            }); // hard-code it to production url atm instead of 'http://localhost:8080/uhoh'\n          }\n        });\n      });\n    });\n  },\n  // listenForBlackListIncrement: function () {\n  //   // increment blocks in Blacklist table when a blacklisted site is blocked\n\n  //   return chrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n  //     chrome.storage.sync.get(['auth', 'blackList'], function (result) {\n  //       const { auth, blackList } = result;\n  //       console.log('blackList in background:', blackList);\n  //       if (blackList) {\n  //         const blackListAuth = blackList.filter((entry) => {\n  //           return entry.userId === auth.id;\n  //         });\n  //         const url = changeInfo.pendingUrl || changeInfo.url;\n  //         if (url) {\n  //           const matchingBlackList = blackListAuth.find((entry) => {\n  //             return entry.site.siteUrl === url;\n  //           });\n\n  //           if (matchingBlackList) {\n  //             matchingBlackList.blocks++;\n  //             console.log('matchingBlackList:', matchingBlackList);\n  //             chrome.storage.sync.set({ updatedBlackList: matchingBlackList });\n  //           }\n  //         }\n  //       }\n  //     });\n  //   });\n  // },\n\n  listenForBlockedSite: function () {\n    return chrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n      if (changeInfo.url) {\n        getStoredBlackList().then((blackList) => {\n          if (blackList) {\n            if (blackList.includes(changeInfo.url)) {\n              chrome.tabs.update(tabId, {\n                url: 'https://pomodoro-go-1.herokuapp.com/uhoh',\n              });\n            }\n          }\n        });\n      }\n    });\n  },\n\n  listenForAlarm: function () {\n    return chrome.alarms.onAlarm.addListener(function (alarm) {\n      // notifies the user when the session is over\n      console.log('alarm in background');\n      chrome.notifications.create(\n        undefined,\n        {\n          type: 'basic',\n          title: 'Your focus session is complete!',\n          message: 'Nice job! You deserve a break!',\n          iconUrl: 'logo-pomo.png',\n          requireInteraction: true,\n          silent: false,\n        },\n        () => {\n          console.log('last error: ', chrome.runtime.lastError);\n        }\n      );\n      chrome.storage.local.set({\n        alarmCreated: false,\n        currentSession: {},\n        timerOn: false,\n        sessionTime: 0,\n        sessionComplete: true,\n      });\n    });\n  },\n  listenForDashboardRedirect: function () {\n    // THIS BUTTON WORKS BUT DASHBOARD DOES NOT LOAD\n    return chrome.notifications.onButtonClicked.addListener(\n      async (notificationId, buttonIdx) => {\n        // redirects to dashboard after session is complete\n        let tab = await this.getCurrentTab();\n        chrome.tabs.update(tab.id, {\n          url: 'https://pomodoro-go-1.herokuapp.com/dashboard',\n        });\n      }\n    );\n  },\n};\n\nbackground.init();\n","export function setStoredBlackList(blackList) {\n  const vals = {\n    blackList,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredBlackList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['blackList'], (res) => {\n      resolve(res.blackList);\n    });\n  });\n}\n\nexport function setStoredAuth(auth) {\n  const vals = {\n    auth,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredAuth() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['auth'], (res) => {\n      resolve(res.auth);\n    });\n  });\n}\n"],"sourceRoot":""}
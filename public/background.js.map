{"version":3,"sources":["webpack://pomodoro_go/./client/background.js","webpack://pomodoro_go/./client/storage.js"],"names":["storage","tabs","runtime","alarms","chrome","action","onClicked","addListener","tab","create","url","active","currentTab","sessionTime","appStarted","getCurrentTab","async","query","currentWindow","init","this","sync","clear","clearAll","console","log","listenForAlarm","listenToExternalMessages","listenToStorage","listenToTabs","listenForDashboardRedirect","error","createAlarm","when","Date","now","alarmCreated","set","resetStorage","local","timerOn","currentSession","sessionComplete","user","email","onMessageExternal","message","sender","sendResponse","sites","blockedSites","forEach","site","push","siteUrl","blocked","currUser","get","results","find","toggleSite","update","filter","each","onChanged","changes","namespace","key","oldValue","newValue","Object","entries","JSON","stringify","onUpdated","tabId","changeInfo","reduce","previous","current","lastAccessed","pendingUrl","startsWith","hostname","URL","userAttempt","Array","isArray","domain","includes","options","method","headers","body","fetch","err","onAlarm","alarm","name","notifications","undefined","type","title","iconUrl","requireInteraction","silent","lastError","onButtonClicked","notificationId","buttonIdx","id","Promise","resolve","res","blackList","then","blackListUrls","i","length"],"mappings":"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","file":"background.js","sourcesContent":["'use strict';\nconst { storage, tabs, runtime, alarms } = chrome;\nimport { getStoredBlackList } from './storage';\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.tabs.create({\n    url: 'index.html',\n  });\n});\n\nconst background = {\n  active: false,\n  currentTab: null,\n  sessionTime: 0,\n  appStarted: false,\n  getCurrentTab: async function () {\n    let queryOptions = { active: true, currentWindow: true };\n    let [tab] = await chrome.tabs.query(queryOptions);\n    return tab;\n  },\n  init: async function () {\n    try {\n      if (!this.active) {\n        storage.sync.clear();\n        alarms.clearAll(() => {\n          console.log('alarms are cleared');\n        });\n\n        this.listenForAlarm();\n        this.listenToExternalMessages();\n        this.listenToStorage();\n        this.listenToTabs();\n        this.listenForDashboardRedirect();\n        this.active = true;\n      }\n      this.currentTab = await this.getCurrentTab();\n    } catch (error) {\n      console.log('issue with start up in background js', error);\n    }\n  },\n  createAlarm: function () {\n    chrome.alarms.create('timer', {\n      when: Date.now() + this.sessionTime,\n    });\n    this.alarmCreated = true;\n    chrome.storage.sync.set({ alarmCreated: true });\n  },\n  resetStorage() {\n    storage.local.set({\n      sessionTime: 0,\n      timerOn: false,\n      currentSession: {},\n      alarmCreated: false,\n      sessionComplete: false,\n      user: {},\n      email: '',\n    });\n  },\n\n  listenToExternalMessages: function () {\n    return runtime.onMessageExternal.addListener(\n      async (message, sender, sendResponse) => {\n        try {\n          if (message.message === 'create-timer') {\n            this.sessionTime = message.sessionTime;\n            this.createAlarm();\n          }\n          if (message.message === 'continue-alarm') {\n            console.log('you want me to start an alarm?');\n            alarms.clearAll(() => {\n              console.log('alarms are cleared again');\n              alarms.create('timer', {\n                when: Date.now() + message.sessionTime,\n              });\n              console.log('new alarm created');\n            });\n          }\n          if (message.message === 'timer-done') {\n            alarms.create('timer', { when: Date.now() });\n          }\n          if (message.message === 'set-blocked-sites') {\n            console.log('set-blocked-sites message received');\n            const sites = [];\n            message.blockedSites.forEach((site) => {\n              sites.push(site.siteUrl);\n            });\n            chrome.storage.sync.set(\n              { blocked: sites, currUser: message.currUser },\n              () => {\n                console.log('sites are blocked in chrome');\n              }\n            );\n            console.log('blocked sites', message);\n            chrome.storage.sync.get(null, (results) => {\n              console.log('current chrome storage', results);\n            });\n          }\n          if (message.message === 'toggle-block-or-not') {\n            chrome.storage.sync.get(['blocked'], (results) => {\n              const doesItExist = results.blocked.find((url) => {\n                return url === message.toggleSite;\n              });\n              if (doesItExist) {\n                const update = results.blocked.filter((each) => {\n                  return each !== message.toggleSite;\n                });\n                chrome.storage.sync.set({ blocked: update });\n              } else {\n                results.blocked.push(message.toggleSite);\n                chrome.storage.sync.set({ blocked: results.blocked });\n              }\n            });\n          }\n        } catch (error) {\n          console.log(error);\n        }\n      }\n    );\n  },\n  listenToStorage: function () {\n    return storage.onChanged.addListener(async function (changes, namespace) {\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${JSON.stringify(\n            oldValue\n          )}\", new value is \"${JSON.stringify(newValue)}\".`\n        );\n      }\n    });\n  },\n  listenToTabs: function () {\n    return tabs.onUpdated.addListener(function (tabId, changeInfo) {\n      chrome.tabs.query({ active: false }, (tabs) => {\n        let tab = tabs.reduce((previous, current) => {\n          return previous.lastAccessed > current.lastAccessed\n            ? previous\n            : current;\n        });\n      });\n      chrome.storage.sync.get(null, (results) => {\n        const {\n          currentSession,\n          alarmCreated,\n          sessionComplete,\n          sessionTime,\n          timerOn,\n        } = results;\n        const url = changeInfo.pendingUrl || changeInfo.url;\n        if (!url || !url.startsWith('http')) {\n          return;\n        }\n        const hostname = new URL(url).hostname;\n\n        storage.sync.set({ userAttempt: hostname });\n\n        storage.sync.get(['blocked', 'currUser'], async function (sync) {\n          const { blocked, currUser } = sync;\n          if (\n            Array.isArray(blocked) &&\n            blocked.find((domain) => {\n              return domain.includes(hostname);\n            })\n          ) {\n            const options = {\n              method: 'post',\n              headers: {\n                'Content-type':\n                  'application/x-www-form-urlencoded; charset=UTF-8',\n              },\n              body: `userAttempted=${hostname}&userId=${currUser}`,\n            };\n\n            try {\n              await fetch(\n                'https://pomodoro-go-1.herokuapp.com/api/blocks',\n                options\n              );\n            } catch (err) {\n              console.error('Request failed', err);\n            }\n\n            chrome.tabs.update(tabId, {\n              url: 'https://pomodoro-go-1.herokuapp.com/uhoh',\n            }); // hard-code it to production url atm instead of 'http://localhost:8080/uhoh'\n          }\n        });\n      });\n    });\n  },\n\n  listenForAlarm: function () {\n    return chrome.alarms.onAlarm.addListener(function (alarm) {\n      if (alarm.name === 'startTimer') {\n        chrome.notifications.create(\n          undefined,\n          {\n            type: 'basic',\n            title: 'Your focus session is complete!',\n            message: 'Nice job! You deserve a break!',\n            iconUrl: 'logo-pomo.png',\n            requireInteraction: true,\n            silent: false,\n          },\n          () => {\n            console.log('last error: ', chrome.runtime.lastError);\n          }\n        );\n        chrome.storage.local.set({\n          alarmCreated: false,\n          currentSession: {},\n          timerOn: false,\n          sessionTime: 0,\n          sessionComplete: true,\n        });\n      }\n    });\n  },\n  listenForDashboardRedirect: function () {\n    // THIS BUTTON WORKS BUT DASHBOARD DOES NOT LOAD\n    return chrome.notifications.onButtonClicked.addListener(\n      async (notificationId, buttonIdx) => {\n        // redirects to dashboard after session is complete\n        let tab = await this.getCurrentTab();\n        chrome.tabs.update(tab.id, {\n          url: 'https://pomodoro-go-1.herokuapp.com/dashboard',\n        });\n      }\n    );\n  },\n};\n\nbackground.init();\n\nchrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n  if (changeInfo.url) {\n    getStoredBlackList().then((blackListUrls) => {\n      if (blackListUrls) {\n        for (let i = 0; i < blackListUrls.length; i++) {\n          if (\n            changeInfo.url.includes(blackListUrls[i]) &&\n            blackListUrls[i].length\n          ) {\n            chrome.tabs.update(tabId, {\n              url: `${process.env.API_URL}/uhoh`,\n            });\n          }\n        }\n      }\n    });\n  }\n});\n","export function setStoredBlackList(blackList) {\n  const vals = {\n    blackList,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredBlackList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['blackList'], (res) => {\n      resolve(res.blackList);\n    });\n  });\n}\n\nexport function setStoredIsRunning(isRunning) {\n  chrome.storage.local.set({ isRunning });\n}\n\nexport function getStoredIsRunning() {\n  chrome.storage.local.get(['isRunning'], (res) => {\n    resolve(res.isRunning);\n  });\n}\n\nexport function setStoredTimer(timer) {\n  const vals = {\n    timer,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredTimer() {\n  chrome.storage.local.get(['timer'], (res) => {\n    resolve(res.timer);\n  });\n}\n\nexport function setStoredDisplayTime(displayTime) {\n  const vals = {\n    displayTime,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredDisplayTime() {\n  chrome.storage.local.get(['displayTime'], (res) => {\n    resolve(res.displayTime);\n  });\n}\n\nexport function setStoredAuth(auth) {\n  const vals = {\n    auth,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredAuth() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['auth'], (res) => {\n      resolve(res.auth);\n    });\n  });\n}\n"],"sourceRoot":""}
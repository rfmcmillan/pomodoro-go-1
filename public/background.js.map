{"version":3,"sources":["webpack://pomodoro_go/./client/storage.js","webpack://pomodoro_go/./client/background.js"],"names":["setStoredIsRunning","isRunning","chrome","storage","local","set","setStoredTimer","timer","vals","Promise","resolve","tabs","runtime","alarms","scripting","action","onClicked","addListener","tab","create","url","active","currentTab","sessionTime","appStarted","getCurrentTab","async","query","currentWindow","init","this","console","log","sync","clear","clearAll","listenForAlarm","listenToExternalMessages","listenToStorage","listenToTabs","listenForBlockedSite","listenForDashboardRedirect","error","createAlarm","when","Date","now","alarmCreated","resetStorage","timerOn","currentSession","sessionComplete","user","email","onMessageExternal","message","sender","sendResponse","sites","blockedSites","forEach","site","push","siteUrl","blocked","currUser","get","results","find","toggleSite","update","filter","each","onChanged","changes","namespace","key","oldValue","newValue","Object","entries","JSON","stringify","onUpdated","tabId","changeInfo","reduce","previous","current","lastAccessed","pendingUrl","startsWith","hostname","URL","userAttempt","Array","isArray","domain","includes","options","method","headers","body","fetch","err","res","blackList","then","onAlarm","alarm","name","notifications","undefined","type","title","iconUrl","requireInteraction","silent","lastError","onButtonClicked","notificationId","buttonIdx","id","periodInMinutes","time","displayTime","setStoredDisplayTime","ms","seconds","hours","parseInt","minutes","msToHMS"],"mappings":"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","file":"background.js","sourcesContent":["export function setStoredBlackList(blackList) {\n  const vals = {\n    blackList,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredBlackList() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['blackList'], (res) => {\n      resolve(res.blackList);\n    });\n  });\n}\n\nexport function setStoredIsRunning(isRunning) {\n  chrome.storage.local.set({ isRunning });\n}\n\nexport function getStoredIsRunning() {\n  chrome.storage.local.get(['isRunning'], (res) => {\n    resolve(res.isRunning);\n  });\n}\n\nexport function setStoredTimer(timer) {\n  const vals = {\n    timer,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredTimer() {\n  chrome.storage.local.get(['timer'], (res) => {\n    resolve(res.timer);\n  });\n}\n\nexport function setStoredDisplayTime(displayTime) {\n  const vals = {\n    displayTime,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredDisplayTime() {\n  chrome.storage.local.get(['displayTime'], (res) => {\n    resolve(res.displayTime);\n  });\n}\n\nexport function setStoredAuth(auth) {\n  const vals = {\n    auth,\n  };\n  return new Promise((resolve) => {\n    chrome.storage.local.set(vals, () => {\n      resolve();\n    });\n  });\n}\n\nexport function getStoredAuth() {\n  return new Promise((resolve) => {\n    chrome.storage.local.get(['auth'], (res) => {\n      resolve(res.auth);\n    });\n  });\n}\n","'use strict';\nconst { storage, tabs, runtime, alarms, scripting } = chrome;\nimport { getStoredBlackList } from './storage';\nimport {\n  setStoredIsRunning,\n  setStoredTimer,\n  setStoredDisplayTime,\n} from './storage';\n\nconst msToHMS = (ms) => {\n  let seconds = ms / 1000;\n\n  let hours = parseInt(seconds / 3600);\n  seconds = seconds % 3600;\n\n  let minutes = parseInt(seconds / 60);\n  seconds = seconds % 60;\n\n  hours = hours < 10 ? '0' + hours : hours;\n  minutes = minutes < 10 ? '0' + minutes : minutes;\n  seconds = seconds < 10 ? (seconds >= 0 ? '0' + seconds : '00') : seconds;\n\n  return hours + ':' + minutes + ':' + seconds;\n};\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.tabs.create({\n    url: 'index.html',\n  });\n});\n\nconst background = {\n  active: false,\n  currentTab: null,\n  sessionTime: 0,\n  appStarted: false,\n  getCurrentTab: async function () {\n    let queryOptions = { active: true, currentWindow: true };\n    let [tab] = await chrome.tabs.query(queryOptions);\n    return tab;\n  },\n  init: async function () {\n    try {\n      if (!this.active) {\n        console.log('running app!');\n        storage.sync.clear();\n        setStoredIsRunning(false);\n        setStoredTimer(null);\n        alarms.clearAll(() => {\n          console.log('alarms are cleared');\n        });\n\n        this.listenForAlarm();\n        this.listenToExternalMessages();\n        this.listenToStorage();\n        this.listenToTabs();\n        this.listenForBlockedSite();\n        this.listenForDashboardRedirect();\n        this.active = true;\n      }\n      this.currentTab = await this.getCurrentTab();\n    } catch (error) {\n      console.log('issue with start up in background js', error);\n    }\n  },\n  createAlarm: function () {\n    chrome.alarms.create('timer', {\n      when: Date.now() + this.sessionTime,\n    });\n    this.alarmCreated = true;\n    chrome.storage.sync.set({ alarmCreated: true });\n  },\n  resetStorage() {\n    storage.local.set({\n      sessionTime: 0,\n      timerOn: false,\n      currentSession: {},\n      alarmCreated: false,\n      sessionComplete: false,\n      user: {},\n      email: '',\n    });\n  },\n\n  listenToExternalMessages: function () {\n    return runtime.onMessageExternal.addListener(\n      async (message, sender, sendResponse) => {\n        try {\n          if (message.message === 'create-timer') {\n            this.sessionTime = message.sessionTime;\n            this.createAlarm();\n          }\n          if (message.message === 'continue-alarm') {\n            console.log('you want me to start an alarm?');\n            alarms.clearAll(() => {\n              console.log('alarms are cleared again');\n              alarms.create('timer', {\n                when: Date.now() + message.sessionTime,\n              });\n              console.log('new alarm created');\n            });\n          }\n          if (message.message === 'timer-done') {\n            alarms.create('timer', { when: Date.now() });\n          }\n          if (message.message === 'set-blocked-sites') {\n            console.log('set-blocked-sites message received');\n            const sites = [];\n            message.blockedSites.forEach((site) => {\n              sites.push(site.siteUrl);\n            });\n            chrome.storage.sync.set(\n              { blocked: sites, currUser: message.currUser },\n              () => {\n                console.log('sites are blocked in chrome');\n              }\n            );\n            console.log('blocked sites', message);\n            chrome.storage.sync.get(null, (results) => {\n              console.log('current chrome storage', results);\n            });\n          }\n          if (message.message === 'toggle-block-or-not') {\n            chrome.storage.sync.get(['blocked'], (results) => {\n              const doesItExist = results.blocked.find((url) => {\n                return url === message.toggleSite;\n              });\n              if (doesItExist) {\n                const update = results.blocked.filter((each) => {\n                  return each !== message.toggleSite;\n                });\n                chrome.storage.sync.set({ blocked: update });\n              } else {\n                results.blocked.push(message.toggleSite);\n                chrome.storage.sync.set({ blocked: results.blocked });\n              }\n            });\n          }\n        } catch (error) {\n          console.log(error);\n        }\n      }\n    );\n  },\n  listenToStorage: function () {\n    return storage.onChanged.addListener(async function (changes, namespace) {\n      // logging out the changes in storage\n      // THIS CODE IS FOR DEV PURPOSES\n      // YOU WILL HAVE ALOT OF LOGS IN CONSOLE\n      for (let [key, { oldValue, newValue }] of Object.entries(changes)) {\n        console.log(\n          `Storage key \"${key}\" in namespace \"${namespace}\" changed.`,\n          `Old value was \"${JSON.stringify(\n            oldValue\n          )}\", new value is \"${JSON.stringify(newValue)}\".`\n        );\n      }\n    });\n  },\n  listenToTabs: function () {\n    return tabs.onUpdated.addListener(function (tabId, changeInfo) {\n      console.log('listening to tabs, tabID', tabId);\n      chrome.tabs.query({ active: false }, (tabs) => {\n        let tab = tabs.reduce((previous, current) => {\n          return previous.lastAccessed > current.lastAccessed\n            ? previous\n            : current;\n        });\n      });\n      chrome.storage.sync.get(null, (results) => {\n        const {\n          currentSession,\n          alarmCreated,\n          sessionComplete,\n          sessionTime,\n          timerOn,\n        } = results;\n        const url = changeInfo.pendingUrl || changeInfo.url;\n        if (!url || !url.startsWith('http')) {\n          return;\n        }\n        const hostname = new URL(url).hostname;\n\n        storage.sync.set({ userAttempt: hostname });\n\n        storage.sync.get(['blocked', 'currUser'], async function (sync) {\n          const { blocked, currUser } = sync;\n          if (\n            Array.isArray(blocked) &&\n            blocked.find((domain) => {\n              return domain.includes(hostname);\n            })\n          ) {\n            const options = {\n              method: 'post',\n              headers: {\n                'Content-type':\n                  'application/x-www-form-urlencoded; charset=UTF-8',\n              },\n              body: `userAttempted=${hostname}&userId=${currUser}`,\n            };\n\n            try {\n              await fetch(\n                'https://pomodoro-go-1.herokuapp.com/api/blocks',\n                options\n              );\n            } catch (err) {\n              console.error('Request failed', err);\n            }\n\n            chrome.tabs.update(tabId, {\n              url: 'https://pomodoro-go-1.herokuapp.com/uhoh',\n            }); // hard-code it to production url atm instead of 'http://localhost:8080/uhoh'\n          }\n        });\n      });\n    });\n  },\n\n  listenForBlockedSite: function () {\n    return chrome.tabs.onUpdated.addListener(function async(tabId, changeInfo) {\n      if (changeInfo.url) {\n        // const hostname = new URL(url).hostname;\n        // console.log(hostname);\n        getStoredBlackList().then((blackList) => {\n          if (blackList) {\n            if (blackList.includes(changeInfo.url)) {\n              chrome.tabs.update(tabId, {\n                url: `${process.env.API_URL}/uhoh`,\n              });\n            }\n          }\n        });\n      }\n    });\n  },\n\n  listenForAlarm: function () {\n    return chrome.alarms.onAlarm.addListener(function (alarm) {\n      if (alarm.name === 'startTimer') {\n        chrome.notifications.create(\n          undefined,\n          {\n            type: 'basic',\n            title: 'Your focus session is complete!',\n            message: 'Nice job! You deserve a break!',\n            iconUrl: 'logo-pomo.png',\n            requireInteraction: true,\n            silent: false,\n          },\n          () => {\n            console.log('last error: ', chrome.runtime.lastError);\n          }\n        );\n        chrome.storage.local.set({\n          alarmCreated: false,\n          currentSession: {},\n          timerOn: false,\n          sessionTime: 0,\n          sessionComplete: true,\n        });\n      }\n    });\n  },\n  listenForDashboardRedirect: function () {\n    // THIS BUTTON WORKS BUT DASHBOARD DOES NOT LOAD\n    return chrome.notifications.onButtonClicked.addListener(\n      async (notificationId, buttonIdx) => {\n        // redirects to dashboard after session is complete\n        let tab = await this.getCurrentTab();\n        chrome.tabs.update(tab.id, {\n          url: 'https://pomodoro-go-1.herokuapp.com/dashboard',\n        });\n      }\n    );\n  },\n};\n\nbackground.init();\n\n//Timer in Background\nchrome.alarms.create('oneSecond', {\n  periodInMinutes: 1 / 60,\n});\n\nchrome.alarms.onAlarm.addListener((alarm) => {\n  if (alarm.name === 'oneSecond') {\n    chrome.storage.local.get(['isRunning', 'timer'], (res) => {\n      console.log('res.timer in background.js:', res.timer);\n      console.log('res.isRunning:', res.isRunning);\n      const time = res.timer ?? 0;\n\n      if (time === 0) {\n        setStoredIsRunning(false);\n        return;\n      }\n      if (!res.isRunning) {\n        return;\n      }\n      const displayTime = msToHMS(time - 1000);\n      setStoredDisplayTime(displayTime);\n      console.log('time in background.js:', time);\n      setStoredTimer(time - 1000);\n    });\n  }\n});\n"],"sourceRoot":""}